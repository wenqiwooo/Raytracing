<!DOCTYPE html>
<html>
  <head>
    <script src="gpu.js"></script>
  </head>
  <body>
    <script>

    	function Enum(constantsList) {
      		for (var i in constantsList) {
         		this[constantsList[i]] = i;
      		}
   		}

    	var ObjTyp = new Enum(['EMPTY', 'SPHERE', 'CUBOID', 'CYLINDER', 'CONE', 'TRIANGLE']);


    	var camera = [
      		0,0,2,                     // x,y,z 
      		4,4,4,                     // Direction normal 
      		45                         // field of view : example 45
   		];

   		var lights = [
      		2,                                                                                     
      		200,200,200, 0,1,0,        // light 1, x,y,z location, and rgb 
      		100,100,100, 1,1,1,        // light 2, x,y,z location, and rgb 
   		];

    	var objects = [
      			2, // number of objects                               
      			ObjTyp.SPHERE,      13, 1.0,0.0,0.0,0.2,0.7,0.1,1.0, 100,500,500,40,           
      			// typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,           
      			ObjTyp.SPHERE,      13, 0.0,0.0,1.0,0.2,0.7,0.1,1.0, 200,600,200,20            
      			// typ,recsz,r,g,b,spec,lamb,amb,opac, x,y,z,rad,            

   		];

      	var gpu = new GPU();

      	function sqr(x) {
      		return x*x;
   		}

		function dist(x1,y1,x2,y2) {
		    return Math.sqrt( sqr(x2-x1)+sqr(y2-y1) );
		}

		gpu.addFunction(sqr);
		gpu.addFunction(dist);

    function doit(mode){
  		var opt = {
          	dimensions: [800,600],
          	debug: true,
          	graphical: true,
          	safeTextureReadHack: false,
          	constants: { OBJCOUNT: objects[0],     
                          EMPTY: ObjTyp.EMPTY,    SPHERE: ObjTyp.SPHERE,   CUBOID: ObjTyp.CUBOID, 
                        	CYLINDER: ObjTyp.CYLINDER,   CONE: ObjTyp.CONE,   TRIANGLE: ObjTyp.TRIANGLE },
           	mode: mode
        	};

  		var kObj = gpu.createKernel(function(Objects) {
  		    var idx = 1;                                     // index for looking through all the objects
           	var nextidx = 1; 
           	this.color(0.95,0.95,0.95);                      // By default canvas is light grey
           	for (i=0; i<this.constants.OBJCOUNT; i++ ) {     // Look at all object records
              	idx = nextidx;                               // Skip to next record
               	nextidx = Objects[idx+1]+idx;                // Pre-compute the beginning of the next record
               	if (Objects[idx] == this.constants.SPHERE) { // i.e. if it is a SPHERE...
                  	// if (dist(this.thread.x,this.thread.y,Objects[idx+9],Objects[idx+10]) < Objects[idx+12]) {
                   //    	this.color(Objects[idx+2],Objects[idx+3],Objects[idx+4]);
                  	// }
                    //if (this.thread.y == 0){
                      this.color(Objects[idx+2],Objects[idx+3],Objects[idx+4], 100/this.thread.x);
                    //}
               	}
           	}
  		}, opt);
      return kObj;
    }

    var mykernel = doit("gpu");
    mykernel(camera,lights,objects);
		var canvas = kObj.getCanvas();
		document.getElementsByTagName('body')[0].appendChild(canvas);

    var f = document.querySelector("#fps");
    function renderLoop() {
      f.innerHTML = fps.getFPS();
      if (selection === 0) {
        mycode(camera,lights,objects);
        var cv = document.getElementsByTagName("canvas")[0];
        var bdy = cv.parentNode;
        var newCanvas = mycode.getCanvas();
        bdy.replaceChild(newCanvas, cv);
      } else {
        mykernel(camera,lights,objects);
        var cv = document.getElementsByTagName("canvas")[0];
        var bdy = cv.parentNode;
        var newCanvas = mykernel.getCanvas();
        bdy.replaceChild(newCanvas, cv);
      }
      objects[10] = (objects[10]+2) % 900;
      objects[24] = (objects[24]+2) % 700;
//      setTimeout(renderLoop,1);            // Uncomment this line, and comment the next line
      requestAnimationFrame(renderLoop);     // to see how fast this could run...
    }
    window.onload = renderLoop;

    </script>
  </body>
</html>